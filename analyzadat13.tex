\documentclass[12pt,fleqn,a4paper,proc]{article}

\usepackage{graphicx}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage{times}

\usepackage[czech]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage[T1]{fontenc}     

% \usepackage[utf8x]{inputenc}  % pro unicode UTF-8
% \usepackage[cp1250]{inputenc} % pro win1250
% \usepackage[T1]{fontenc}


\usepackage{float}
\floatname{algorithm}{Algoritmus}


\newcommand{\Real}{{\cal R}}

\title{Přírodou inspirované prohledávací algoritmy a jejich aplikace}
\author{Roman Neruda\\
Ústav informatiky AV ČR, v.v.i.\\
Pod Vodárenskou věží 2\\
182 07 Praha\\
\texttt{roman@cs.cas.cz}
}
\date{}

\begin{document}
\sloppy 
\pagestyle{empty}

\maketitle

\begin{abstract}
V tomto článku přinášíme stručný přehled algoritmů prohledávání, které jsou inspirované přírodními jevy jako je evoluce nebo chování sociálního hmyzu. Základními princpy těchto algoritmů je heuristické prohledávání prostoru pomocí generování kandidátů řešení problému a ověňeníni jejich úspěšnosti, populační prohledávání, kde jedinci v populacích soupeří o možnost reprodukce, a rekombinace kandidátů za účelem nalezení lepších řešení. V práci nejprve popíšeme obecný evoluční algoritmus a následně se zaměříme na jeho konkrétní varianty: genetické algoritmy, evoluční programování, evoluční strategie a genetické programování. Popíšeme také neuroevoluční algoritmy pro evoluční učení struktury a parametrů neuronových síti a rojové algoritmy. 
\end{abstract}

\thispagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Úvod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Prohledávání prostoru řešení parametricky zadaných úloh je jedním z hlavních problémů mnoha oblastí informatiky i matematiky. Aplikace prohledávání jsou nesčetné a zahrnují optimalizaci reálných parametrů, kombinatorickou optimalizaci, automatický vývoj programů, učení robotů nebo návrh architektury a učení neuronových sítí. Přírodou inspirované algoritmy přinesly do tohoto oboru několik nových přístupů, které jsou schopny efektivně pracovat i ve vysoce dimenzionálních prostorech, optimalizovat nelineární funkce s lokálními extrémy a pracovat v tak strukturovaných prostorech jako jsou syntaktické stromy, grafy nebo neuronové sítě. 

Výhodou většiny přístupů zmíněných v tomto článku je jejich obecnost. Evoluční i rojové techniky můžeme chápat jako metaheuristiky, které nevyžadují mnoho specifických informací o řešené úloze, kromě ohodnocení jednotlivých kandidátů řešení prostřednictvím účelové funkce nazývané též ohodnocovací funkce nebo fitness. Výhodou tohoto přístupu je snadná aplikovatelnost generického algoritmu na široké spektrum úloh. Na druhou stranu, existují teoretické i praktické důvody pro přizpůsobení obecných prohledávacích heuristik dané úloze. Takto přizpůsobené metody obvykle dosahují lepších výsledků a zároveň si uchovávají obecné výhody těchto technik, jako je odolnost proti uváznutí v lokálních extrémech. 

Hlavním rysem zde uváděných přírodou inspirovaných prohledávacích technik je populační přístup. Na rozdíl od většiny algoritmů lokálního prohledávaní, které zkoumají nejbližší okolí jednoho bodu v prohledávacím prostoru, evoluční techniky pracují s populací desítek až tisíců řešení, které paralelně prohledávají prostor řešení a navzájem se ovlivňují. 

Lokální prohledávací metody šité na míru určitému problému typicky mají výhodu rychlejšího lokálního prohledávání díky využití specifických informací o problému, jako je například informace o gradientu účelové funkce. V dalším textu se zmíníme také o možnosti hybridizovat některé evoluční algoritmy pomocí specifického lokálního prohledávání. Tato technika se v~praxi osvědčuje zrychlením konvergence algoritmu, i když někdy přináší větší nebezpečí uváznutí v lokálních extrémech účelové funkce. Je zajímavé, že z~hlediska původní biologické inspirace představuje tato hybridizace překročení darwinistického rámce a přináší lamarckistické či epigenetické prinicpipy. 

V následujícím textu nejprve stručně zmíníme inspiraci a obecné rysy evolučních algoritmů a pak se budeme věnovat několika konkrétním oblastem vycházejících z těchto obecných principů. Nejprve popíšeme tradiční genetické algoritmy pracující původně nad binárně zakódovanými jedinci. Dále budeme hovořit o evolučním programování, oblasti která stírá rozdíl mezi genotypem (zakódováním jedince pro účely evolučního prohledávání) a fenotypem (vlastním modelem, který vznikne dekódováním genotypu). Evoluční strategie byly prvním přístupem specializujícím se na optimalizaci reálných parametrů a také přinesly první koncept meta-evoluce, optimalizace parametrů evoluce pomocí vlastního evolučního algoritmu. Genetické programování je příkladem úspěšné evoluce složitých struktur syntaktických stromů počítačových programů. Neuroevoluce ukazuje možnosti využití evolučních technik pro určení struktury i parametrů modelů neuronových sítí. Oblast rojových algoritmů se inspiruje chováním společenského hmyzu a hejn pro efektivní prohledávání různých prostorů, např. reálných euklidovských prostorů nebo hledání cest v grafech. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Obecné schéma evolučního algoritmu}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Oblast evolučních výpočtů či algoritmů (v angličtině evolutionary computing) zastřešuje několik proudů, které se zpočátku vyvíjely samostatně. Za prehistorii této disciplíny lze považovat Turingovy návrhy na využizí evolučního prohledávání z roku 1948 a Bremermannovy první pokusy o implementaci optimalizace pomocí evoluce a rekombinace z roku 1962. Během šedesátých let se objevily tři skupiny výzkumníků, kteří nezávisle na sobě vyvíjely a navrhly své varianty použití evolučních principů v informatice. Holland publikoval v roce 1975 svůj návrh genetických algoritmů, zatímco skupina Fogela a spolupracovníků vyvinula metodu nazvanou evoluční programování. Nezávisle na nich přišli Rechenberg a Schwefel v Německu na metodu nazvanou evoluční strategie. Až do přelomu osmdesátých a devadesátých let existovaly tyto směry bez výraznější interakce, ale poté se spojily do obecnější oblasti evolučních algoritmů. V té době  Koza vytváří metodu genetického programování, Dorigo publikuje disertaci s návrhem mravenčích optimalizačních algoritmů a vznikají první pokusy o aplikaci evoluce na vývoj umělých neuronových sítí. 

U zrodu různých variant evolučních algoritmů stála inspirace přírodními fenomény, konkrétně jde o Darwinovu teorii přírodního výběru a zjednodušené principy genetiky, které poprvé načrtl Mendel. Z genetiky se evoluční algoritmy inspirují diskrétní reprezentací genotypu, z biologické evoluční teorie používají Darwinovu myšlenku o výběru jedinců v prostředí s omezenými zdroji, který závisí na míře přizpůsobení se jedinců danému prostředí.

Základní obecnou myšlenku evolučních algoritmů lze vyjádřit následujícím způsobem. Mějme populaci jedinců v prostředí, které určuje jejich úspěšnost --- fitness. Tito jedinci navzájem soupeří o možnost reprodukce a přežití, která závisí právě na hodnotě fitness. Jde tedy o množinu kandidátů na řešeni problému definovaného prostředím. Způsoby reprezentace jedinců, jejich výběru a rekombinace závisí na konkrétním dialektu evolučních algoritmů, které probereme vzápětí. 

\begin{algorithm}
\caption{Schéma evolučního algoritmu}
\label{obreva}
\begin{algorithmic}
\Procedure{Evoluční algoritmus}{} 
\State $t \gets 0$
\State \emph{Inicializuj} populaci $P_t$ náhodně vygenerovanými jedinci
\State \emph{Ohodnoť} jedince v populaci $P_t$
\While{neplatí \emph{kritérium ukončení}}
\State 	vyber z $P_t$ rodiče \emph{Rodičovskou selekcí}
\State 	\emph{Rekombinací} rodičů vzniknou potomci
\State 	\emph{Mutuj} potomky
\State 	\emph{Ohodnoť} potomky
\State 	\emph{Enviromentální selekcí} vyber $P_{t+1}$ z $P_t$ a potomků
\State $t \gets t+1$
\EndWhile
%\Until{kritérium ukončení}
\EndProcedure
\end{algorithmic}
\end{algorithm}


Základní princip fungování evolučních algoritmů je tedy následující \cite{eiben}. Na začátku algoritmu vygenerujeme (nejčastěji náhodně) první iniciální populaci jedinců. Všechny jedince v populaci ohonotíme ohodnocovací funkcí. Hodnota této funkce určuje šanci výběru jedinců během rodičovské selekce. Vybraní jedinci jsou potom rekombinováni pomocí rekombinačního operátoru, který typicky ze dvou jedinců vytváří jednoho či dva potomky, a pomoci operátoru mutace, který typicky provádí drobné změny jednoho jedince. Tímto postupem si vytvoříme množinu nových kandidátů řešení, a tito noví jedinci potom soutěží s původními jedinci o místo v nové populaci. Výběr jedinců do nové populace (tedy jakési slití rodičů a potomků) má na starosti enviomentální selekce beroucí v úvahu fitness jedinců a připadně další ukazatele jako je například stáří jedinců. Tím je vytvořena nová generace a tento cyklus pokračuje do splnění určitého kritéria ukončení, což je nejčastěji dostatečně dobrý nejlepší jedinec nebo předem určený počet generací.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Genetické algoritmy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Genetické algoritmy jsou asi nejznámější součástí evolučních výpočtů a v~různých obměnách se používají hlavně při řešení optimalizačních úloh. Je zajímavé, že původní Hollandovou motivací při návrhu genetického algoritmu bylo studovat vlastnosti přírodou inspirované adaptace \cite{holland}. Velká část původní literatury byla věnována popisu principů, jak genetický algoritmus pracuje při hledání řešení úlohy. Zajímavé jsou paralely s matematickým problémem dvourukého bandity, který je příkladem na udržování optimální rovnováhy mezi explorací a exploatací. 

Nejjednodušší varianta genetického algoritmu pracuje s binárními jedinci, to znamená, že parametry řešené úlohy je nutno vždy zakódovat jako binární řetězce. Tento přístup je výhodný z hlediska jednoduchosti použitých operátorů, ale binární zakódování na druhou stranu nemusí být nejvhodnější reprezentací problému. Způsob fungování jednoduchého genetického algoritmu je také poměrně jednoduchý. Algoritmus přechází mezi populacemi řešení tak, že nová populace zcela nahradí předchozí. Výběr rodičů je často realizován tzv. ruletovou selekcí, která vybírá jedince náhodně~s pravděpodobností výběru úměrné jejich fitness. Rekombinačním operátorem je jednobodové křížení, které náhodně zvolí stejnou pozici v rodičích a vyměňí jejich části. Pravděpodobnost uskutečnění operace křížení je jedním z parametrů programu a obvykle je poměrně vysoká (0,5 i více). Mutace provádí drobné lokální změny tak, že prochází jednotlivé bity řetězce a každý bit s~velmi malou pravděpodobností změní. Pravděpodobnost mutace je typicky nastavena, tak aby došlo průměrně ke změně jednoho bitu v populaci (oblíbená dolní mez) nebo v jedinci (horní mez). 

\begin{algorithm}
\caption{Schéma Hollandova gentického algoritmu}
\label{obrga}
\begin{algorithmic}
\Procedure{Jednoduchý genetický algoritmus}{} 
\State $t \gets 0$
\State \emph{Inicializuj} populaci $P_t$ $N$ náhodně vygenerovanými binárními jedinci délky $n$
\State \emph{Ohodnoť} jedince v populaci $P_t$
\While{neplatí \emph{kritérium ukončení}}
\For{$i \gets 1, \dots, N/2$}
\State 	vyber z $P_t$ 2 rodiče \emph{Ruletovou selekcí}
\State 	S pravděpodobností $p_C$ \emph{Zkřiž} rodiče
\State 	S pravděpodobností $p_M$ \emph{Mutuj} potomky
\State 	\emph{Ohodnoť} potomky
\State  Přidej potomky do $P_{t+1}$
\EndFor
\State 	Zahoď $P_t$
\State $t \gets t+1$
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

Ruletovou selekci si dle metafory můžeme představit tak, že kolo rulety rozdělíme na výseče odpovídající velikostí hodnotám fitness jedinců a při výběru pak $n$ krát vhodíme kuličku. Často používaným vylepšením ruletové selekce je tzv. stochastický univerzální výběr, který hodí kuličku do rulety jen jednou a další jedince vybírá deterministicky posunem pozice kuličky o $1/n$. Tento výběr pro malá $n$ lépe aproximuje ideální počty zastoupení jedinců v další generaci. Dalšími varianty rodičovské selekce nepracují s absolutními hodnotami fitness, ale vybírají náhodně v závislosti na pořadí jedince v populaci setříděné podle fitness, což zanedbává absolutní rozdíly mezi hodnotami. Další variantou rodičovské selekce je tzv $k$-turnaj, kdy nejprve vybereme $k$ jedinců náhodně a z nich pak vybereme nejlepšího. 

V současnosti se oblast genetických algoritmů neomezuje jen na binární kódování jedinců, časté je celočíselné, permutační nebo reálné kódování, která ale vyžadují specifické operace křížení a mutace \cite{michal, mitchel}. O některých se zmíníme dále. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evoluční programování}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Evoluční programování je oblast, která je na rozdíl od genetických algoritmů charakterizována velmi benevolentním přístupem ke kódování jedinců. První varianty tohoto přístupu vznikly jako metoda pro automatickou evoluci konečných automatů \cite{fogel}. Jedincem v populaci je v tomto připadě tedy konečný automat (zakódovaný jakkoliv) a variační operace se omezují na několik různých mutací. Pro evoluční programování je charakteristické, že mutace jsou přizpůsobené problému a je jich často více, zatímco křížení se vůbec nepoužívá. 

V dalším textu popíšeme variantu evolučního programování, která pracuje s jedinci reprezentovanými vektory reálných čísel. Rodičovská selekce je jednoduchá, každý rodič je jednou vybrán a mutací dá vznik jednomu potomkovi. Enviromentální selekce potom z množiny rodičů a potomků vybere turnajovou selekcí polovinu, která se stane další generací. 

\begin{algorithm}
\caption{Schéma meta-evolučního programování nad vektorem reálných čisel}
\label{obrep}
\begin{algorithmic}
\Procedure{Meta-EP}{} 
\State $t \gets 0$
\State \emph{Inicializuj} populaci $P_t$ $N$ náhodně vygenerovanými reálnými vektory $\vec{x^t}=(x_1^t,\dots,x_n^t,\sigma_1^t,\dots,\sigma_n^t)$
\State \emph{Ohodnoť} jedince v populaci $P_t$
\While{neplatí \emph{kritérium ukončení}}
\For{$i \gets 1, \dots, N$}
\State 	k rodiči $\vec{x_i^t}$ vygenruj potomka $\vec{y_i^t}$ \emph{mutací}:
\For{$j \gets 1, \dots, n$}
\State $\sigma'_j \gets \sigma_j \cdot (1+\alpha \cdot N(0,1))$
\State $x'_j \gets x_j + \sigma'_j \cdot N(0,1)$

\EndFor
\State vlož $\vec{y_i^t}$ do kandidátské populace potomků $P'_t$
\EndFor
\State 	\emph{Turnajovou selekcí} vyber $P_{t+1}$ z rodičů $P_t$ a potomků $P'_t$
\State 	Zahoď $P_t$ a $P'_t$
\State $t \gets t+1$
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
 
Mutace v našem připadě pracuje tak, že se snaží o malou změnu reálné hodnoty, kterou realizuje výběrem z normálního rozdělení. Ukázalo se, že hodnoty rozptylu normálního rozdělení jednotlivých parametrů jsou podstatné pro dobré fungování algoritmu. Jedno z navržených řešení je začlenit tyto rozptyly do každého jedince a upravovat je také v průběhu algoritmu. Jelikož tak vlastně upravujeme parametry, které zároveň používáme při vlastní mutaci, hovoříme o meta-evoluci.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evoluční strategie}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Evoluční strategie byly navrženy pro práci s reálnými vektory reprezentujícími parametry složitých optimalizačních problémů \cite{schwefel}. V ukázkovém algoritmu vidíme jednoduchou verzi, která pracuje s jedním jedincem v populaci generujícím jednoho potomka pomocí gaussovské mutace popsané výše. Toto schéma lze snadno rozšířit na populaci $n$ jedinců, která generuje $m$ potomků (typicky je $m>n$). Enviromentální selekce se dělí na tzv. $(n+m)$ strategii, která $n$ nových jedinců generuje deterministicky výběrem lepších z množiny rodičů i potomků, a na tzv. $(n,m)$ strategii, která $n$ nových jedinců vybírá deterministicky jen z potomků. Ukazuje se, že druhá strategie je robustnější proti uváznutí v lokálních extrémech.

\begin{algorithm}
\caption{Schéma základní dvouprvkové evoluční strategie pro minimalizaci účelové funkce $f:\Real^n\to\Real$}
\label{obrsches}
\begin{algorithmic}
\Procedure{Evoluční strategie (1+1)}{}
\State $t \gets 0$
\State Generuj náhodně počáteční bod $(x_1^t, \dots , x_l^t)\in\Real^n$
\While{$\left(f(\vec{x^t})>\mbox{\emph{kritérium ukončení}}\right)$}
\For{$i \gets 1, \dots, l$}
\State 	zvol $z$ z normálního rozdělení
\State 	$y_i^t \gets x_i^t + z$
\EndFor
\If{$f(\vec{x^t})\leq f(\vec{y^t})$}
\State $\vec{x^{t+1}} \gets \vec{x^t}$
\Else
\State $\vec{x^{t+1}} \gets \vec{y^t}$
\EndIf
\State $t \gets t+1$
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

Skutěcně používané evoluční strategie jsou také charakteristické používáním adaptačních mutací popsaných v předchozí části, které mohou kromě rozptylů obsahovat i další parametry. Na rozdíl od evolučního programování, křížení je v evolučních strategiích používáno. U křížení reálných vektorů jsou nejčastější dva přístupy (používané i v ostatních oblastech evolučních algoritmů). Uniformní křížení je zobecněním jednobodového křížení, které ale pro každou složku jedince rozhoduje náhodně, zda bude pocházet z prvního nebo druhého rodiče. Dalším typem křížení jsou tzv. aritmetická křížení, která se snaží kombinovat hodnoty jednotlivých parametrů rodičů. Nejčastějším způsobem je průměrování nebo konvexní kombinace hodnot. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Genetické programování}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Gentické programování je zajímavé tím, že přináší práci s jedinci odlišného typu --- jde o stromy reprezentující programy \cite{koza}. Strom je sestaven z množiny neterminálních symbolů reprezentujících funkce a množiny terminálních symbolů (listů) reprezentujících proměnné a konstanty. Proměnné jsou charakterizovány úlohou k řešení, neterminální symboly určují programovací jazyk, ve kterém budou programy vznikat. Stromy jsou vhodné jednak proto, že představují kompaktní reprezentaci programů, a také proto, že na nich lze elegantně provádět křížení realizované jako výměna náhodně zvolených podstromů mezi dvěma jedinci. Mutace je realizována jako nahrazení podstromu náhodně vygenerovaným podstromem. Je zajímavé, že v kontrastu s jinými oblastmi evolučních algoritmů, nehraje mutace v genetickém programování tak významnou roli a obvykle mívá malou pravděpodobnost. Je to pravděpodobně způsobeno tím, že křížení představuje ve stromu programu velké změny, které tak suplují i účinek mutace.

Náhodné generování stromů je důležitou operací jak pro inicializaci populace tak pro mutace. Byly navrženy dvě metody, které se snaží buď náhodně generovat kompletní strom dané hloubky, anebo náhodně rostou větve stromů. Druhá metoda generuje tedy řidší stromy s nestejně dlouhými větvemi. Pro inicializaci se doporučuje kombinace těchto metod v poměru 1:1 (ramped half-and-half).

\begin{algorithm}
\caption{Schéma Kozova algoritmu genetického programování nad syntaktickými stromy}
\label{obrsgp}
\begin{algorithmic}
\Procedure{Genetické programování}{} 
\State $t \gets 0$
\State \emph{Inicializuj} populaci $P_t$ metodou \emph{ramped half-and-half}
\State \emph{Ohodnoť} jedince v populaci $P_t$
\While{neplatí \emph{kritérium ukončení}}
\State $i \gets 0$
\Repeat
\State vyber pravděpodobnostně variační operaci $o\in\{C,M\}$
\If{o=C} \Comment Křížení
\State vyber z $P_t$ 2 rodiče
\State \emph{Zkřiž} rodiče
\State vlož potomky do $P_{t+1}$
\State $i \gets i + 2$
\Else \Comment Mutace
\State vyber z $P_t$ 1 rodiče
\State \emph{Mutuj} rodiče
\State vlož potomka do $P_{t+1}$
\State $i \gets i + 1$
\EndIf
\Until{$i\geq n$}
\State \emph{Ohodnoť} jedince v populaci $P_{t+1}$
\State 	Zahoď $P_t$
\State $t \gets t+1$
\EndWhile
%\Until{kr
\EndProcedure
\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Neuroevoluce}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
Použití evolučních algoritmů pro učení neuronových sítí je oblast zkoumaná od přelomu osmdesátých a devadesátých let. První pokusy se týkaly učení vah sítě s předem danou strukturou, jde tedy o využití evolučního algoritmu jako alternativy ke standardnímu učení neuronových sítí založených typicky na lokálních metodách gradientní optimalizace \cite{neuro}. 
Tato úloha není příliš složitá, parametry sítě zakódujeme do reálného vektoru a na něj použijeme jeden z výše popsaných algoritmů. Výpočet fitness pak znamená spočítat chybu neuronové sítě na množině trénovacích dat.

Dnes z experimentů víme, že evoluční algoritmus těžko soupeří v rychlosti s nejlepšími gradientními algoritmy, nicméně jeho výhody pro učení parametrů sítě jsou robustnost proti uváznutí v lokálních extrémech a snadná paralelizace. Jednou z oblastí, kde je evoluční algoritmus pro učení neuronových síti nezastupitelný, jsou případy tzv. posilováného učení, kde není k dispozici informace o chybě sítě pro každý vstup. Tyto případy jsou velmi časté v robotice, kdy teprve z chování robota v delším časovém úseku můžeme odvodit jeho úspěšnost. V této oblasti je evoluční učení neuronových sítí takřka nezastupitelné, i proto se často hovoří o oboru evoluční robotiky. 

Schopnost evoluční algoritmů optimalizovat i složitěji reprezentované struktury vedla ke snahám použít je pro optimalizaci velikosti a propojení jednotek uvnitř sítě, mluvíme o strukturálním učení. Toto učení lze rozdělit podle toho, zda reprezentace sítě je zakódovaná do jedince evolučního algoritmu přímo či nepřímo. Další dělení je, zda se struktura učí najednou společně s parametry sítě (takže kódujeme obě komponenty v jednom genomu) anebo se struktura učí zvlášť a učení parametrů sítě je vlastně záležitostí výpočtu fitness jedince. Při tomto rozdělení úlohy na učení struktury a parametrů je zajímavé si uvědomit, že učit parametry lze libovolným algoritmem, třeba další evolucí.

Při přímých metodách učení struktury sítě se většinou pracuje s reprezentací pomocí matice propojení neuronů v síti. Tato matice může být booleovská (v připadě reprezentace struktury) nebo reálná (pro reprezentaci struktrury i hodnot vah spojů v síti). Jelikož matice propojení může být poměrně velká, vznikly snahy o kompaktní vyjádření struktury sítě, které je často nepřímé. Kitano navrhl gramatické kódování booleovské matice spojů, které uvažuje dvojrozměrnou gramatiku schopnou v logaritmickém prostoru popsat matice navíc s možnosti zachytit symetrie struktury. Gruau navrhl jinou metodu založenou na principu genetického programování, kde program je vlastně návod na sestrojení sítě metodou růstu z minimální konfigurace \cite{gruau}. 

Jednou z dnes nejúspěšnějších neuroevolučních metod je Stanleyho Neat (neuroevolution of augmenting topologies) \cite{stanley}. Jde o přímou metodu vyvíjející zároveň strukturu i parametry sítě opět postupem od minimální konfigurace ke složitějším. Autor elegantně vyřešil problém, jak má vlastně vypadat křížení dvou sítí s různou topologií. Používá k tomu globální paměť evoluční historie tvaru sítě jednoduše realizovatelnou pomocí tzv. rodného čísla spoje, díky kterému lze určit, které hrany v grafu sítě si evolučně odpovídají, a ty se pak mohou křížit. Důležitým problémem při současném učení struktury a parametrů se ukázal krátkodobý negativní vliv strukturálních změn na kvalitu sítě a z toho vyplývající nutnost ochrany strukturálně nových jedinců, kteří potřebují čas na doladění svých parametrů. To je v Neatu opět řešeno pomocí využití rodných čísel hran pro určení podobných sítí a relativizací fitness uvnitř množin podobných sítí. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rojové algoritmy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Rojové algoritmy mají některé společné rysy s evolučními algoritmy, jako je populační prohledávání, ale jsou charakteistické tím, že kladou důraz na modelování pohybu populace v prostoru parametrů inspirovaném různými druhy organizace sociálního hmyzu nebo jiných živočichů v hejnech. Počáteční výzkum Reynoldse vedl k návrhu jednoduchého lokálního algoritmu tzv. boidů, kteří velice jednoduše a překvapivě dobře modelují organizaci roje a koordinovaný pohyb v něm. Teprve algoritmus optimalizace rojem částic (PSO) ale přinesl využití těchto principů do prohledávacích algoritmů. V současnosti existuje celá řada dalších přibuzných algoritmů od ant colony optimization přes umělé imunitní systémy až ke včelím algoritmům \cite{swarm}. 

Principem fungování rojově optimalizace je organizovaný pohyb roje částic (jedinců) po prostoru parametrů. Každá částice je charakterizována svou polohou a vektorem rychlosti. Každá častice si také pamatuje ze své historie nejlepší místo (ve smyslu hodnoty účelové funkce), které ona sama v historii navštívila a globální dosud nejlepší místo nalezené celým rojem. V každém kroku pak částice upraví svou rychlost jako součet tři vektorů: současné rychlosti, směru k lokálnimu extrému častice a směru ke globálnímu extrému celého roje. Tato suma je vážena dílem vstupními parametry algoritmu nastavovanými experimentátorem (jde o nelehký problém závisející na typu dat) a dílem náhodně vygenreovanými koeficienty pro každý krok. 

\begin{algorithm}
\caption{Schéma optimalizace rojem částic minimalizujících $f:\Real^n\to\Real$}
\label{obrswarm}
\begin{algorithmic}
\Procedure{Optimalizace rojem částic}{}
\State $\vec{g} \gets \arg\max_{\vec{y}} f(\vec{y})$ \Comment inicializace globální nejlepší pozice
\For{$i \gets 1, \dots, l$}
\State Inicializuj pozici částice $\vec{x_i}$ náhodně z rovnoměrného rozdělení
\State $\vec{p_i} \gets \vec{x_i}$ \Comment inicializace nejlepší známé pozice částice
\If{$f(\vec{p_i})<f(\vec{g})$}
\State $\vec{g} \gets \vec{p_i}$ \Comment update globální nejlepší pozice
\EndIf
\State Inicializuj rychlost částice $\vec{v_i}$ náhodně z rovnoměrného rozdělení
\EndFor
\While{$\left(f(\vec{x^t})>\mbox{\emph{kritérium ukončení}}\right)$}
\For{$i \gets 1, \dots, l$}
\State 	zvol $r_g$ a $r_p$ z ronvoměrného rozdělení $U(0,1)$
\For{$d \gets 1, \dots, n$} \Comment update rychlosti částice
\State $v_{i,d} \gets \omega v_{i,d} + \varphi_p r_p (p_{i,d} - x_{i,d}) + \varphi_g r_g (g_{i,d} - x_{i,d})$
\EndFor
\State $\vec{x_i} \gets \vec{x_i} + \vec{v_i}$ \Comment update pozice částice
\If{$f(\vec{x_i})<f(\vec{p_i})$}
\State $\vec{p_i} \gets \vec{x_i}$ \Comment update nejlepší pozice částice
\If{$f(\vec{p_i})<f(\vec{g})$}
\State $\vec{g} \gets \vec{p_i}$ \Comment update nejlepší globální pozice
\EndIf
\EndIf
\EndFor
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Závěr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

V tomto příspěvku jsme stručně představili oblast přírodou inspirovaných prohledávacích algoritmů. Nedostalo se na některé moderní či pokročilejší metody v této oblasti, jako je koevoluce, memetické algoritmy, diferenciální evoluce, efektivní paralelní implementace nebo multikriteriální evoluční algoritmy. Vývoj v posledních letech směřuje jednak ke specializaci evolučních technik v závislosti na doméně aplikace, a jednak ke kombinování metod mezi sebou. Časté jsou dnes i kombinace evolučních přístupů s dalšími obory jako jsou například metody kombinatorické optimalizace nebo jiné heuristiky lokálního prohledávání. Evoluční algoritmy jsou svým obecným rámcem vhodné pro nejrůznější kombinace, které se typicky uplatňujǐ v návrhu kódování jedinců a příslušných evolučních operátorů. Jde o bouřlivě se rozvíjející obor, který zapadá do širšího rámce tzv. výpočetní inteligence --- části umělé inteligence inspirované přírodou. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Poděkování}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Tento článek vznikl za podpory projektu MŠMT COST LD 13002.

\begin{thebibliography}{99}

\bibitem{holland}
J. Holland, \emph{Adaptation in Natural and Artificial Systems}, MIT Press, 1995.

\bibitem{fogel}
D. Fogel, \emph{Evolutionary Computation}, MIT Press, 1995.

\bibitem{schwefel}
H.-G. Beyer and H. P. Schwefel, Evolutionary Strategies: A Comprehensive Introduction, \emph{Natural Computing}, 1, 3-52, 2002.

\bibitem{michal}
Z. Michalewicz, \emph{Gentic Algorithms + Data Structures = Evolutionary Programs}, Springer, 1996.

\bibitem{mitchel}
M. Mitchel, \emph{Introduction to Genetic Algorithms}, MIT Press, 1996.

\bibitem{eiben}
A. E. Eiben and J. E. Smith \emph{Introduction to Evolutionary Computing}, Springer, 2003.

\bibitem{koza}
J. Koza, \emph{Genetic Programming}, MIT Press, 1992.

\bibitem{swarm}
J. Kennedy and R. C. Eberhardt, \emph{Swarm intelligence}, Morgan Kaufmann, 2001.

\bibitem{neuro}
I. G. Sher, \emph{Handbook of Neuroevolution Through Erlang}. Springer, 2012.

\bibitem{gruau}
F. Gruau, \emph{Neural network synthesis using cellular encoding and the genetic algorithm}, Ecole Normale Superieure de Lyon, France, 1994.

\bibitem{stanley}
K. O. Stanley and R. Miikkulainen. A Taxonomy for Artificial Embryogeny. \emph{Artificial Life}, 9, 93-130, MIT Press, 2003. 
\end{thebibliography}
\end{document}
